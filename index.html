<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<title>Geometry Dash – Enhanced</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* { box-sizing: border-box; user-select: none; }
body {
    margin: 0; overflow: hidden;
    font-family: Arial, Helvetica, sans-serif;
    color: white;
    background: linear-gradient(135deg, #1e1e1e, #3b1a59, #004d4d);
    background-size: 400% 400%;
    animation: bgAnim 20s ease infinite;
}
@keyframes bgAnim { 0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%} }
.screen { position:absolute; inset:0; display:none; justify-content:center; align-items:center; flex-direction:column; background:rgba(0,0,0,0.7); z-index:10; }
.screen.active { display:flex; }
button { padding:12px 30px; margin:10px; font-size:18px; border:none; border-radius:6px; background:#00ffff; color:#000; cursor:pointer; }
button:hover { background:#00cccc; }
canvas { display:block; margin:auto; border:3px solid #00ffff; }
.slider { width:200px; }
</style>
</head>
<body>

<div id="menu" class="screen active">
    <h1>Geometry Dash – Enhanced</h1>
    <button onclick="showLevelSelect()">Start</button>
    <button onclick="showOptions()">Options</button>
</div>

<div id="levelSelect" class="screen">
    <h2>Velg nivå</h2>
    <button onclick="startGame(1)">Level 1</button>
    <button onclick="startGame(2)">Level 2 (Orbs)</button>
    <button onclick="backToMenu()">Tilbake</button>
</div>

<div id="pause" class="screen">
    <h2>Pause</h2>
    <button onclick="resumeGame()">Fortsett</button>
    <button onclick="backToMenu()">Meny</button>
</div>

<div id="endScreen" class="screen">
    <h2 id="endText">Level Complete!</h2>
    <button onclick="restartGame()">Restart Level</button>
    <button onclick="backToMenu()">Meny</button>
</div>

<div id="options" class="screen">
    <h2>Options</h2>
    <label>SFX Volume: <input type="range" min="0" max="1" step="0.05" value="0.7" class="slider" id="sfxSlider"></label>
    <label>Music Volume: <input type="range" min="0" max="1" step="0.05" value="0.3" class="slider" id="musicSlider"></label>
    <button onclick="backToMenu()">Tilbake</button>
</div>

<canvas id="game" width="900" height="300"></canvas>

<script>
/* ===================== CANVAS ===================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ===================== AUDIO ===================== */
let sfxVolume = 0.7;
let musicVolume = 0.3;
const jumpSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
const crashSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
const music = new Audio("https://cdn.pixabay.com/audio/2022/03/15/audio_75e8c8f6d7.mp3");
music.loop = true; music.volume = musicVolume;
document.getElementById("sfxSlider").addEventListener("input", e=>sfxVolume=parseFloat(e.target.value));
document.getElementById("musicSlider").addEventListener("input", e=>{ musicVolume=parseFloat(e.target.value); music.volume=musicVolume; });

/* ===================== GAME STATE ===================== */
const STATE = { MENU:0, PLAY:1, PAUSE:2, END:3 };
let gameState = STATE.MENU;
let currentLevel = 1;

/* ===================== PLAYER ===================== */
const player = { x:120, y:210, size:30, velY:0, gravity:0.7, jumpForce:-13, rotation:0, coyote:0, buffer:0 };
const COYOTE_TIME=8, BUFFER_TIME=8;

/* ===================== WORLD ===================== */
let gravityDirection=1, speed=4, speedTimer=0, scrollX=0;

/* ===================== PARTICLES ===================== */
let particles=[];

/* ===================== LEVEL ===================== */
let level = [];

/* ===================== INPUT ===================== */
function jumpRequest(){ player.buffer=BUFFER_TIME; }
document.addEventListener("keydown", e => {
    if(e.code==="Space" && gameState===STATE.PLAY) jumpRequest();
    if(e.code==="Escape" && gameState===STATE.PLAY) togglePause();
    if(e.code==="KeyR" && gameState===STATE.PLAY) restartGame();
});
canvas.addEventListener("mousedown", jumpRequest);
canvas.addEventListener("touchstart", e=>{ e.preventDefault(); jumpRequest(); }, {passive:false});

/* ===================== MENY ===================== */
function showLevelSelect(){ document.getElementById("menu").classList.remove("active"); document.getElementById("levelSelect").classList.add("active"); }
function showOptions(){ document.getElementById("menu").classList.remove("active"); document.getElementById("options").classList.add("active"); }
function backToMenu(){
    gameState=STATE.MENU; music.pause();
    ["pause","menu","endScreen","levelSelect","options"].forEach(id=>document.getElementById(id).classList.remove("active"));
    document.getElementById("menu").classList.add("active");
}

/* ===================== FLOW ===================== */
function startGame(levelNumber){
    currentLevel = levelNumber;
    document.getElementById("levelSelect").classList.remove("active");
    resetGame();
    gameState = STATE.PLAY;
    music.play();
}
function resetGame(){
    scrollX=0; speed=4; speedTimer=0; gravityDirection=1;
    player.y=210; player.velY=0; player.rotation=0; player.coyote=0; player.buffer=0;
    particles=[];
    generateLevel(currentLevel);
    document.getElementById("endScreen").classList.remove("active");
}
function restartGame(){ resetGame(); gameState=STATE.PLAY; music.play();}
function togglePause(){ gameState=STATE.PAUSE; document.getElementById("pause").classList.add("active"); }
function resumeGame(){ gameState=STATE.PLAY; document.getElementById("pause").classList.remove("active"); }

/* ===================== LEVEL GENERATOR ===================== */
function generateLevel(n){
    level=[];
    let x=600;
    while(x<4000){
        if(n===1){
            // Enkel tilfeldig hindring
            let type=Math.random()<0.5?"spike":"block";
            if(type==="block"){ level.push({x, type:"block", h:50+Math.floor(Math.random()*50), used:false}); }
            else { level.push({x, type:"spike", used:false}); }
            x += 250 + Math.random()*200; // spacing basert på spiller hopp
        } else if(n===2){
            // Orbs nivå
            let r = Math.random();
            if(r<0.4) level.push({x,type:"spike",used:false});
            else if(r<0.7) level.push({x,type:"block",h:40+Math.random()*60,used:false});
            else level.push({x,type:"orb",used:false});
            x += 200 + Math.random()*150;
        }
    }
    level.push({x: x, type:"portalEnd", used:false});
}

/* ===================== UPDATE ===================== */
function updatePlayer(){
    player.velY += player.gravity * gravityDirection;
    player.y += player.velY;
    player.rotation += 0.15 * gravityDirection;
    const groundY = gravityDirection===1 ? 210:30;
    if((gravityDirection===1 && player.y>=groundY)||(gravityDirection===-1 && player.y<=groundY)){
        player.y=groundY; player.velY=0; player.coyote=COYOTE_TIME; player.rotation=0;
    } else player.coyote=Math.max(0, player.coyote-1);
    if(player.buffer>0 && player.coyote>0){ player.velY=player.jumpForce*gravityDirection; player.buffer=0; player.coyote=0; jumpSound.volume=sfxVolume; jumpSound.play(); }
    player.buffer=Math.max(0, player.buffer-1);
}
function updateLevel(){ scrollX+=speed; if(speedTimer>0) speedTimer--; else speed=4; }
function spawnParticles(){ for(let i=0;i<20;i++){ particles.push({x:player.x+15,y:player.y+15,vx:(Math.random()-0.5)*6,vy:(Math.random()-0.5)*6,life:30}); } }
function updateParticles(){ particles=particles.filter(p=>p.life-->0); particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;}); }

/* ===================== COLLISION ===================== */
function checkCollision(){
    for(let o of level){
        let x=o.x-scrollX;
        if(o.type==="block"){
            let y=gravityDirection===1 ? 260-o.h:0;
            if(player.x< x+40 && player.x+30> x && player.y< y+o.h && player.y+30>y) endGame();
        }
        if(o.type==="spike"){
            const spikeY=gravityDirection===1 ? 230:0;
            if(player.x< x+30 && player.x+30> x && player.y< spikeY+30 && player.y+30>spikeY) endGame();
        }
        if(o.type==="orb" && !o.used && Math.abs(x-player.x)<20){
            player.velY = -10 * gravityDirection; // hoppboost
            o.used=true;
            jumpSound.volume=sfxVolume; jumpSound.play();
        }
        if(o.type==="portalEnd" && Math.abs(x-player.x)<20){ reachEndPortal(); o.used=true; }
    }
}

function reachEndPortal(){
    let interval = setInterval(()=>{
        player.x+=2; player.y+=gravityDirection*2;
        spawnParticles();
        if(player.x>canvas.width/2){ clearInterval(interval); showEndScreen(); }
    },16);
}
function showEndScreen(){ gameState=STATE.END; document.getElementById("endText").innerText = "Level Complete!"; document.getElementById("endScreen").classList.add("active"); music.pause(); }
function endGame(){ crashSound.volume=sfxVolume; crashSound.play(); spawnParticles(); gameState=STATE.MENU; music.pause(); document.getElementById("menu").classList.add("active"); }

/* ===================== DRAW ===================== */
function drawProgress(){
    const p=Math.min(scrollX/4000,1);
    ctx.fillStyle="#222"; ctx.fillRect(0,0,canvas.width,6);
    ctx.fillStyle="#00ffff"; ctx.fillRect(0,0,canvas.width*p,6);
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawProgress();
    ctx.fillStyle="#00ffff"; ctx.fillRect(0,260,canvas.width,4); ctx.fillRect(0,0,canvas.width,4);
    ctx.save(); ctx.translate(player.x+15,player.y+15); ctx.rotate(player.rotation); ctx.fillStyle="#ff00ff"; ctx.fillRect(-15,-15,30,30); ctx.restore();

    for(let o of level){
        let x=o.x-scrollX;
        if(o.type==="block"){ ctx.fillStyle="#ff0000"; ctx.fillRect(x,260-o.h,40,o.h);}
        if(o.type==="spike"){ ctx.fillStyle="#ffff00"; ctx.beginPath(); ctx.moveTo(x,260); ctx.lineTo(x+15,230); ctx.lineTo(x+30,260); ctx.fill();}
        if(o.type==="orb"){ ctx.fillStyle="#00ff00"; ctx.beginPath(); ctx.arc(x+15,210,10,0,2*Math.PI); ctx.fill();}
        if(o.type==="portalEnd"){ ctx.strokeStyle="#ffffff"; ctx.lineWidth=3; ctx.strokeRect(x,180,30,60); ctx.lineWidth=1;}
    }

    ctx.fillStyle="#ff00ff"; particles.forEach(p=>ctx.fillRect(p.x,p.y,4,4));
}

/* ===================== LOOP ===================== */
function loop(){
    if(gameState===STATE.PLAY){ updatePlayer(); updateLevel(); updateParticles(); checkCollision(); draw(); }
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
